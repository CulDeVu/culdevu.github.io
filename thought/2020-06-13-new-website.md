== New website
=== Description here

Last week I redid my website. I've been neglecting it for a couple years now and I want to stop. So this is about what this new one is all about and what I want to do.

# I stare into the abyss

My history of websites is as follows:

- In jr high my website was hosted on link(https://www.webs.com/)[webs.com]. Remember that site? It was all completely handwritten HTML. I think there were javascript animated snowflakes that fell constantly.
- In high school I played around with websites that overuse XmlHttpRequest to load content and format it. Even then I was over handwritten HTML but was still stuck in the dynamically loading website phase. I'm sure high school me would have loved React and friends.
- In college I finally got a domain name and set up Github Pages (which I still use). The first site was using the Jekyll static site generator. That was okay for a while, but if I'm going to be switching back and forth between multiple machines (including a Windows one), I don't want to be installing Ruby all over.
- Next up was Hugo static generator. Hugo was actually really really nice. A single binary that you can just download, works pretty much out of the box. The main issues are with the math formatting and the templates. If you want to typeset math using mathjax, you can't use the default markdown formatter, you have to use the mmark formatter (at least in the versions I was using) which seemed to require random amounts of newlines in multiline equations. In addition, Hugo templates are crazy town and I didn't want to have to learn how to do the gymnastics required to go from a website in my head to a Hugo template.

This leaves us at my current site. The static site generator I wrote takes in almost-markdown and spits out almost-exactly what I want. I figure every computer I ever use to work on my site will have a C compiler on it, so the generator is written in C. [something about how this is a good thing]

Writing my own generator means that I have full control over the output HTML. This means that I get to do that thing where I focus on stupid things that probably don't actually matter. The one I got into my head this time around is that I want very minimal javascript playing with the content of the site. As much pure HTML and CSS as I can manage. I had recently read through a good bit of the CSS spec recently so I figured that with all this newfound knowledge I'd be able to make the site look how I want it without having to feel like I was randomly trying things.

For math typesetting, I chose to go with MathJax. I'm fine with this since it's *reasonably* small enough to check entirely into my repo, and the alternative (using a png latex renderer) ends up having blurriness and mobile issues whenever I've seen it. Plus a page with lots of equations will request tons of images which isn't ideal.

This isn't a major thing, but I don't like the whole "semantic web." Specifically, I don't like the whole `&lt;header&gt;`, `&lt;footer&gt;`, `&lt;article&gt;` kind of tagging for the same reason that I don't like doing things like `typedef int64_t time_diff_t;` in C. It hides the fact that `time_diff_t` is 64bit (as opposed to 32bit, etc) which is an annoying thing to keep having to refer back to if I forget, and I find it hard to keep up my programming speed while also having to pause for a second and think things like "should this return a `time_diff_t` or a `int64_t`? This function returns a `int64_t` and I need a `time_diff_t` out of it, should I cast just for clarity?" over and over. I also don't like functions that don't do anything. Like how some codebases have the concept of a "system unit" that could *conceivably* be any unit but is actually always meters, and then provide a `double su_2_meters(double val) { return val }`. Again, you end up wasting time looking to make sure you put all the correct noop functions in the code, and at the end of the day it has the same problem (but has it arguably worse) as inaccurate comments. The semantic tags are similar. Are they block or inline? Can't tell from just their name, I guess you just have to memorize it. Should I be using `&lt;article&gt;` here, or `&lt;section&gt;`? Or maybe `&lt;main&gt;`? Hm....

So with all that in place, I sat down Friday afternoon and in 2 hours had the pages from my previous site mostly generating right. Basic site layout, navbar, MathJax, generating the post lists, etc. Another 3 hours and almost all of the layout and new content was done, RSS feed was being generated, etc. At this point I'm feeling good: I've been making steady progress and it looks like I should be done in another hour or so just to do some touching up.

Now I didn't know this at the time, but apparently mobile browsers can mess with your formatting. In an effort to try to make non-mobile friendly sites readable, it will artificially shrink your page and sometimes increase font sizes. The way this happens is, from what I can tell, completely heuristically. In addition, while both Chrome nor Firefox had pretty accurate renderings of what the page would look like on mobile, neither of them gave *any* indication of why my text was bigger in some places than others. The area that normally tells you where its sizing parameters came from were completely mum on why the text was 26 pixels large when there's 2 things in the navbar, but 12px when there's 3. As a lot of these types of stories end, I lucked across a link(https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag)[Mozilla reference page] that explains it. So that was fun. Apparently the only way to disable this is to add one non-standard meta tag to your head, and then 3 vendor-specific css tags to your body. Maybe this is old news to front-end veterans, but I think this was a really stupid way to sink and hour or two.

I ran into a multi-hour long issues with images as well. I wanted images to have an optional caption at the bottom, since I've found that a lot of times alt-text is useful information to the reader when the image is loading correctly anyways. In addition to that, I wanted to be able to easily show 2 images side by side horizontally. 

[more here]

# The abyss stares back

I've noticed a pattern in myself over the last few years. My opinion on all of this tends to wildly flip-flop back and forth at predictable intervals. Not on whether or not CSS is shit; that's always been true. It's whether or not I think that pushing through anyways is worth it. The way it goes is this:

**Me, during the up-swing**: "Yes, CSS is garbage and nearly unusable in all but the simplest of scenarios. But so much of the world runs on this language, so as a programmer (or even anyone making a living off of computers) I need to learn it and be comfortable around it. I'm not in a position where I can reasonably live a webtech-hermit existence, and even if I was there's still the problem of employers. The difference between my effectiveness/efficiency when I feel comfortable with my environment, feel in control, and free to make constant progress vs when I don't is *dramatic*. But even if I were to show an employer that difference it wouldn't matter, since developing on software with a team of near-strangers means that everyone is going to be uncomfortable, nobody can feel in control and aware, and rate of progress depends on others. The thing they have to care about is conformity, so just learn the dumb tech that everyone is using, and maybe one day you'll get to the point where you can work in an environment that feels like your personal projects and will make you *want* to come to work every day."

**Me, during the down-swing**: "No... *NO*. No. If these people wanted me to make websites using their language, they wouldn't have made it so completely fucked. Why did I spend 2 hours fiddling with CSS knobs, re-reading specs, and *eventually failing* to get 2 pieces of text to draw at the same baseline? That should take 1 line of code! Those things that make me more effective/efficient also affects how I feel, and I feel bad after I know I did a shitty job. So why would I spend a day of stop-and-go progress, manipulating hierarchies that I know going in won't be able to express the things I want to see output at the end of the day? I've used hierarchies enough times to know they make a very poor stand-in for logic, so why put up with them? Yes all that stuff about employers are true, but there's another road that I can take: when I have to use these things I shouldn't try super hard to do a good job (because I know I won't be able to anyways), and use my remaining energy to focus on the side projects that *do* make me happy. If I can show my ability to make things on my own, maybe someone will hire me and let me do things my way. Or if one of these projects turns out to be sellable, that's another way out. Either way, the road is out and not further in."

It's probably a good thing that those down-swings don't last very long. They seem detrimental to my livelihood. For the past 3 years that I've noticed it, it seems to be a yearly cycle with the down-swing happening around early/mid-summer till around early/mid-fall.

If it's not obvious, this applies to everything. Replace "CSS" with anything you want (anything web, anything corporate, etc) and you should be able to fill in the rest of the nouns fairly easily. That's not to say that these things have no value or are purely bad. But I am saying that if 3 months out of the year I feel like something is pushing me back to my "happy place," there's something wrong.

I'm left wondering whether it was even a good idea to go into programming. Don't get me wrong, I love programming: I love creating things and computers are by far the greatest creation tools humans have ever made. But when I look at people in our sister profession, IT, I feel a little jealous. All the IT people that I've known all seem very chill and relaxed. They all seem to know that everything is broken but they still try to get everything working in the simplest possible way with the least amount of moving parts. Their decisions seem to come from actual experience with actual peoples' problems. This is contrasted against our profession, where it seems to me like solving actual peoples' problems is only an excuse, a backdrop to do what programmers *actually* want, which is to satisfy their aspyness and OCD cravings for everything to exist in hierarchies, for all things to be categorized and organized *just right*. I used to not like the idea of IT, and I told myself that it was because I don't like playing plumber, I don't like it when things fail silently or cryptically, and I don't like feeling like I have no control over a system of things that all act on their own. But looking back at the last couple days redoing this site, and my last year of professional programming I'm reminded of a pot that called a kettle black.

