<html>
	<head>
		<meta charset="UTF-8">
		
		<style>
			body {
				-webkit-text-size-adjust: none;
				-moz-text-size-adjust: none;
				-ms-text-size-adjust: none;

				word-wrap: break-word;
				font-family: sans-serif;
				line-height: 1.2rem;
			}

			.nav {
				display: inline-block;
			}

			.navitem {
				display: inline-block;

				padding: 10px;
				min-width: 100px;
				text-align: center;

				color: #fff;
				text-decoration: none;

				transition: background 0.25s ease;
			}

			.navitem:hover {
				background: #b50;
				/*color: #fa0;*/
				transition: background 0.125s ease;
				color: #fff;
			}

			/* 4*(navitem-width + 2*navitem-padding) + 2*body-padding = 4*(100px + 10px) + 2*(10px) = 500px */
			@media (max-width: 500px) { 
				.navitem {
					width: calc(50% - 20px);
				}
			}

			.codeblock {
				border: 1px solid;
				padding: 1em;
				overflow: auto;
			}

			.codeinline {
				border: 1px solid #aaa;
				border-radius: 3px;
				background-color: #e6e6e6;

				/* Not very good. Will probably depend on the metrics of the font used. Oh well. */
				padding-left: 0.1em;
				padding-right: 0.1em;
			}

			.primary_link {
				color: #000;
				text-decoration: none;
			}
			.primary_link:hover {
				color: #b50;
				text-decoration: none;
			}

			/* For dealing with img()[] elements */
			figure {
				border: 1px solid #888;
				background-color: #e6e6e6;

				margin: 0;
				padding: 1ch;

				display: inline-flex;
				flex-flow: column;
			}
			figcaption {
				margin-top: 0.5rem;
				align-self: center;
			}
			img {
				align-self: center;
				max-width:100%%
			}

			blockquote {
				margin: 0;
				padding-left: 2ch;
				padding-top: 1em;
				padding-bottom: 1em;
				padding-right: 2ch;
				border: 1px solid #888;
				background-color: #e6e6e6;
				border-radius: 3px;

				font-style: italic;
			}

			h2 {
				font-size: 1.25rem;
			}

			.section_heading {
				border-top: 1px dotted;
				padding-top: 1rem;
			}

		</style>

		<meta name="viewport" content="width=device-width, initial-scale=1">
	</head>
	<body style="max-width:980px; padding: 10px; margin:auto; background: #e6e6e6">
		<div style="background: #fafafa; padding: 20px">
			<div><h1 style="margin-top: 0.5em; margin-bottom: 0.3em">djtaylor.me</h1></div>
			<div><i>Insert tagline here</i></div>
		</div>
		<div style="background: #222; color: #fafafa">
			<a href="/" class="navitem">Blog</a><a href="/thought/" class="navitem">Thoughts</a><a href="/portfolio/" class="navitem">Projects</a><a href="/resume/" class="navitem">Resume</a><a href="/physics/" class="navitem">Physics</a>
		</div>

		<div style="background: #fafafa; padding: 20px"><h2 style="margin-bottom:0.5rem">Recursive monte carlo greens functions</h2><i>Pub. 2025 Nov 1</i><p>What follows is </p><p>First I need to set things up.</p><pre class="codeblock"><code>import random
from math import sin, exp, sqrt, pi
from statistics import mean, stdev
import matplotlib.pyplot as plt

def xrange():
  for xi in range(100):
    yield xi / 100
x01 = [x/100 for x in range(100)]
x13 = [x/100 for x in range(100, 300)]
x16 = [x/100 for x in range(100, 600)]
x19 = [x/100 for x in range(100, 900)]
</code></pre><p>x120 = [x/100 for x in range(100, 2000)]</p><pre class="codeblock"><code>def plot(filename, xs, *data):
  plt.clf()
  axis = plt.gca()
  
  plt.plot(xs, data[0])
  
  y_limits = axis.get_ylim()
  
  for dat in data[1:]:
    plt.plot(xs, dat)
  
  axis.set_ylim(y_limits)
  
  plt.savefig(filename, format='svg')

def Hv(x):
  if 0 <= x:
    return 1
  else:
    return 0
</code></pre><p>$$\begin{aligned}\int_0^1 f(s) G(x, s) ds & = A\end{aligned}$$</p><p>Using this to solve $\frac{d^2}{dx^2}u(x) = 2$:</p><pre class="codeblock"><code>def sample_quadratic(x):
  def G(x, s):
    return (x - s)*Hv(x - s) + (s - 1)*x
  
  s = random.random()
  return x + G(x, s) * 2
</code></pre><p>Results:</p><pre class="codeblock"><code>plot('quadratic.svg',
  x01,
  [x*x for x in x01],
  [mean([sample_quadratic(x) for _ in range(100)]) for x in x01])
</code></pre><p><figure><img src="quadratic.svg" style="align-self: center; max-width:100%"></figure></p><pre class="codeblock"><code>def sample_cubic(x):
  def G(x, s):
    return (x - s)*Hv(x - s) + (s - 1)*x
  
  s = random.random()
  return x + G(x, s) * (48*s - 24)

plot('cubic.svg',
  x01,
  [x*(8*x*x - 12*x + 5) for x in x01],
  [mean([sample_cubic(x) for _ in range(100)]) for x in x01])
</code></pre><p><figure><img src="cubic.svg" style="align-self: center; max-width:100%"></figure></p><pre class="codeblock"><code>def sample_laplace1_v1(p, x):
  if x < 0.01:
    return 0
  if 0.99 < x:
    return 1
  
  def G(x, s):
    return (x - s)*Hv(x - s) + (s - 1)*x
  
  s = random.random()
  return x + G(x, s) * p * sample_laplace1_v1(p, s)

plot('wave_small.svg',
  x01,
  [sin(2 * x) / sin(2) for x in x01],
  [mean([sample_laplace1_v1(-4, x) for _ in range(100)]) for x in x01])
</code></pre><p><figure><img src="wave_small.svg" style="align-self: center; max-width:100%"></figure></p><h4>Homogeneous boundary conditions</h3><p>One of the problems to look into is how to deal with 0's for the boundary conditions. I want to be able to do solve something like $\frac{d^2 u}{dx^2}(x) = -\pi^2 x$ with $x(0) = x(1) = 0$ and get out a function of the form $u(x) = C \sin (2 \pi x)$.</p><p>Finding non-trivial solutions to equations like this is required to make the electron orbital simulator. All of the wavefunction boundary conditions are 0.</p><p>Simply rewriting the above <code class="codeinline">sample_laplace1_v1</code>, replacing boundary conditions:</p><pre class="codeblock"><code>def sample_laplace1_homogeneous(p, x):
  if x < 0.01:
    return 0
  if 0.99 < x:
    return 0
  
  def G(x, s):
    return (x - s)*Hv(x - s) + (s - 1)*x
  
  s = random.random()
  return G(x, s) * p * sample_laplace1_homogeneous(p, s)
</code></pre><p>This only produces the trivial solution $u(x) = 0$. This makes sense, since the algorithm is multiplicative, and all recursions terminate in 0.</p><p>Splitting the domain:</p><pre class="codeblock"><code>def sample_laplace1_otherside(p, x):
  if x < 1.02:
    return 1
  if 2.98 < x:
    return 0
  
  def G(x, s):
    return (x - s)*Hv(x - s) + ((s-3)/2)*x -(s-3)/2
  
  s = 1 + random.random()*2
  return 1.5 - 0.5*x + G(x, s) * p * sample_laplace1_otherside(p, s)*2

plot('homogeneous.svg',
  x01+x13,
  [2*sin(pi*x/3)/sqrt(3) for x in x01+x13],
  [mean([sample_laplace1_v1(-pi*pi/9, x) for _ in range(100)]) for x in x01] +
  [mean([sample_laplace1_otherside(-pi*pi/9, x) for _ in range(100)]) for x in x13])
</code></pre><p><figure><img src="homogeneous.svg" style="align-self: center; max-width:100%"></figure></p><p>Another thing I'm interested in is the resilience of this technique to the parameter $p$. The equation $\frac{d^2 u}{dx^2}(x) = p x$ with $x(0) = x(3) = 0$ has nontrivial solutions for ONLY $p = -k \pi^2 / 9$. For my intended uses I'm probably only going to be able to compute $p$ approximately. I want this technique to sort of work even if $p$ is a little off.</p><pre class="codeblock"><code>plot('homogeneous_almost.svg',
  x01+x13,
  [2*sin(pi*x/3)/sqrt(3) for x in x01+x13],
  [mean([sample_laplace1_v1(-pi*pi/9 + 0.4, x) for _ in range(100)]) for x in x01] +
  [mean([sample_laplace1_otherside(-pi*pi/9 + 0.4, x) for _ in range(100)]) for x in x13])
</code></pre><p><figure><img src="homogeneous_almost.svg" style="align-self: center; max-width:100%"><figcaption>$p = -\pi^2/9 + 0.4$</figcaption></figure></p><p>Nice! This means that approximate choices of $p$ give approximately correct answers. Also, I can dial in $p$ by looking at the derivatives near the split point.</p><p>TODO: does sphere walking like in the paper work?</p><p>TODO: in 2D?</p><h4>Large p</h3><p>Another problem is that this function doesn't actually work for all $p$. Take a look at $p = -16$:</p><pre class="codeblock"><code>plot('wave_large.svg',
  x01,
  [sin(4 * x) / sin(4) for x in x01],
  [mean([sample_laplace1_v1(-16, x) for _ in range(100)]) for x in x01])
</code></pre><p><figure><img src="wave_large.svg" style="align-self: center; max-width:100%"></figure></p><p>In fact, no value of $p < -\pi^2$ works!</p><p>Why not?</p><p>After the above discussion this isn't too surprising. At more negative values of $p$ the frequency of $u$ increases. For $p \in (-\pi^2, 0)$ the solution $u$ only contained a half period of a wave at max. For $p \in (-4\pi^2, -\pi^2)$ and beyond it's a full period. So beyond $-\pi^2$ you're always going to have negative numbers in the $[0, 1]$ subdomain.</p><p>Much like above, <code class="codeinline">sample_laplace1_v1</code> can't produce negative numbers when $p$ is negative. $G$ is non-positive, $x$ is non-negative, and the terminal cases are both non-negative.</p><p>... but this feels a little unsatisfying.</p><p>complexity</p><p>derivation</p><h4>polynomial</h3><p>Actually, the fact that it diverges outside of $(-\pi^2, \pi^2)$ makes me think of the convergence of Taylor series. With a Taylor series you have a convergence region of a ball centered on your root position, with a radius of the distance to the nearest complex pole.</p><p>Fixing $x$ and looking at <code class="codeinline">sample_laplace1_v1</code> as a function of $p$, there is a pole at $p = -\pi^2$, so if this were the correct intuition then this behavior would make sense.</p><p>I don't know why I didn't think of this before. </p><pre class="codeblock"><code>plot('exp_small.svg',
  x01,
  [exp(2-2*x) * (exp(4*x) - 1) / (exp(4) - 1) for x in x01],
  [mean([sample_laplace1_v1(4, x) for _ in range(100)]) for x in x01])
</code></pre><p><figure><img src="exp_small.svg" style="align-self: center; max-width:100%"></figure></p><pre class="codeblock"><code>plot('exp_large.svg',
  x01,
  [exp(4-4*x) * (exp(8*x) - 1) / (exp(8) - 1) for x in x01],
  [mean([sample_laplace1_v1(16, x) for _ in range(100)]) for x in x01])
</code></pre><p><figure><img src="exp_large.svg" style="align-self: center; max-width:100%"></figure></p><pre class="codeblock"><code>def prange_lo():
  return[i/5 for i in range(-100, 0)]
def prange_hi():
  return [i/5 for i in range(1, 100)]

plot('p.svg',
  prange_lo() + [0] + prange_hi(),
  [sin(sqrt(-p)*0.3) / sin(sqrt(-p)) for p in prange_lo()] +
  [0.3] +
  [exp(sqrt(p)*(1-0.3)) * (exp(2*sqrt(p)*0.3) - 1) / (exp(2*sqrt(p)) - 1) for p in prange_hi()],
  [mean([sample_laplace1_v1(p, 0.2) for _ in range(100)]) for p in prange_lo() + [0] + prange_hi()])
</code></pre><p><figure><img src="p.svg" style="align-self: center; max-width:100%"></figure></p><p>Here's the theoretical derivative table</p><ul><li>0th: 0.3</li><li>1st: -0.0455</li><li>2nd: 0.0102072</li><li>3rd: approx -0.00318547</li><li>4th: (only verified right sided) 0.00129975</li></ul><pre class="codeblock"><code>def mul_poly(a, b):
  out = [0 for _ in range(len(a) + len(b))]
  for i,ai in enumerate(a):
    for j,bj in enumerate(b):
      out[i+j] += ai * bj
  return out

def sample_laplace1_v1_poly(p, x):
  if x < 0.01:
    return [0]
  if 0.99 < x:
    return [1]
  
  def G(x, s):
    return (x - s)*Hv(x - s) + (s - 1)*x
  
  s = random.random()
  out = mul_poly([0, G(x, s)], sample_laplace1_v1_poly(p, s))
  out[0] += x
  return out

from functools import reduce
from math import factorial
def add_poly(a, b):
  out = []
  for i in range(max(len(a), len(b))):
    if i < len(a) and i < len(b):
      out.append(a[i] + b[i])
    elif i < len(a):
      out.append(a[i])
    elif i < len(b):
      out.append(b[i])
  return out
polys = [sample_laplace1_v1_poly(1, 0.3) for _ in range(10)]
poly = reduce(add_poly, polys, [0])
poly = mul_poly([1/10], poly)
</code></pre><p>Now mine. Left are my computed values, right are the Taylor series coefficients.</p><pre class="codeblock"><code>(poly[0] * factorial(0), 0.3)
</code></pre><blockquote>(0.3, 0.3)</blockquote><pre class="codeblock"><code>(poly[1] * factorial(1), -0.0455)
</code></pre><blockquote>(-0.0531234707420423, -0.0455)</blockquote><pre class="codeblock"><code>(poly[2] * factorial(2), 0.0102072)
</code></pre><blockquote>(0.009342148713005673, 0.0102072)</blockquote><pre class="codeblock"><code>(poly[3] * factorial(3), -0.00318547)
</code></pre><blockquote>(-0.0036301001957742794, -0.00318547)</blockquote><pre class="codeblock"><code>(poly[4] * factorial(4), 0.00129975)
</code></pre><blockquote>(0.0012629861607769736, 0.00129975)</blockquote><p>That looks right. So apparently <code class="codeinline">sample_laplace1_v1</code> is computing the Taylor series of the solution of the differential equation somehow.</p><p>I was floored when I saw this.</p><p>TODO: why does this work?</p><h4>No endpoints</h3><p>What would happen if I just messed up the two base cases? Like if I put the wrong values in them.</p><pre class="codeblock"><code>def G_laplace_01(x, s):
  return (x - s)*Hv(x - s) + (s - 1)*x

def sample_laplace1_wrong_endpoints(p, x):
  if x < 0.01:
    return 2
  if 0.99 < x:
    return -1
  
  s = random.random()
  return x + G_laplace_01(x, s) * p * sample_laplace1_wrong_endpoints(p, s)

plot('wrong_endpoints.svg',
  x01,
  [sin(2 * x) / sin(2) for x in x01],
  [mean([sample_laplace1_wrong_endpoints(-4, x) for _ in range(100)]) for x in x01])
</code></pre><p><figure><img src="wrong_endpoints.svg" style="align-self: center; max-width:100%"></figure></p><p>With the exception of the endpoints, the curve looks good. Meaning that the endpoints aren't necessary for the algorithm.</p><p>Here's a redesigned one:</p><pre class="codeblock"><code>def sample_laplace1_no_endpoints(p, x):
  def one_sample(x, accum):
    cutoff = min(1, abs(accum))
    if cutoff < random.random():
      return 0
    
    s = random.random()
    weight = p * G_laplace_01(x, s)
    return (x + weight * one_sample(s, accum * weight)) / cutoff
  
  return one_sample(x, 1)

plot('no_endpoints.svg',
  x01,
  [sin(2 * x) / sin(2) for x in x01],
  [mean([sample_laplace1_no_endpoints(-4, x) for _ in range(100)]) for x in x01])
</code></pre><p><figure><img src="no_endpoints.svg" style="align-self: center; max-width:100%"></figure></p><p>There's a bit more variance, but that's to be expected.</p><p>TODO: re-anchor</p><p>TODO: walk-on-stars</p><h4>s orbital</h3><pre class="codeblock"><code>def s_orbital_01(r):
  def one_sample(x):
    cutoff = 0.95
    if cutoff < random.random():
      return 0
    
    s = random.random()
    return (x + G_laplace_01(x, s) * -2 * (1/s - 0.5) * one_sample(s)) / cutoff
  
  return one_sample(r)

def G_laplace_16(x, s):
  return (x - s)*Hv(x - s) + (s - 6)/5*x - (s-6)/5
def s_orbital_16(r, m=6):
  def one_sample(x, accum):
    # cutoff = min(1, abs(accum))
    cutoff = 0.98
    if cutoff < random.random():
      return 0
    
    s = 1 + random.random() * 5
    weight = G_laplace_16(x, s) * -2 * (1/s - 0.5) * m
    return (6/5 - x/5 + weight * one_sample(s, accum * weight)) / cutoff
  
  return one_sample(r, 1)

def G_laplace_19(x, s):
  return (x - s)*Hv(x - s) + (s - 9)/8*x - (s-9)/8
def s_orbital_19(r, m=8):
  def one_sample(x, accum):
    # cutoff = min(1, abs(accum))
    cutoff = 0.98
    if cutoff < random.random():
      return 0
    
    s = 1 + random.random() * 8
    weight = G_laplace_19(x, s) * -2 * (1/s - 0.5) * m
    return (9/8 - x/8 + weight * one_sample(s, accum * weight)) / cutoff
  
  return one_sample(r, 1)

plot('s_orbital_09.svg',
  x01 + x19,
  [exp(-x)*x*exp(1) for x in x01 + x19],
  [mean([s_orbital_01(r) for _ in range(100)]) for r in x01] +
  [mean([s_orbital_19(r) for _ in range(100)]) for r in x19])
</code></pre><p>print([stdev([s_orbital_09(r) for _ in range(100)]) for r in x19])</p><p><figure><img src="s_orbital_09.svg" style="align-self: center; max-width:100%"></figure></p><pre class="codeblock"><code>plot('param_19.svg',
  [m/10 for m in range(30)],
  [mean([s_orbital_19(2, m/10) for _ in range(100)]) for m in range(30)])
</code></pre><p><figure><img src="param_19.svg" style="align-self: center; max-width:100%"></figure></p><pre class="codeblock"><code>plot('s_orbital_06.svg',
  x01 + x16,
  [exp(-x)*x*exp(1) for x in x01 + x16],
  [mean([s_orbital_01(r) for _ in range(100)]) for r in x01] +
  [mean([s_orbital_16(r) for _ in range(100)]) for r in x16])
</code></pre><p>print([stdev([s_orbital_09(r) for _ in range(100)]) for r in x19])</p><p><figure><img src="s_orbital_06.svg" style="align-self: center; max-width:100%"></figure></p><pre class="codeblock"><code>plot('param_16.svg',
  [m/10 for m in range(60)],
  [mean([s_orbital_16(2, m/10) for _ in range(100)]) for m in range(60)])
</code></pre><p><figure><img src="param_16.svg" style="align-self: center; max-width:100%"></figure></p></div><div style="background-color: #222; padding: 1em; color: #fafafa">Written by Daniel Taylor.<br>Email: contact@djtaylor.me<br><br><span style="color: #aaa">Â© 2024 by Daniel Taylor</span></div><script id="MathJax-script" async src="/3rd-party/mathjax/tex-mml-chtml.js"></script><script>window.MathJax = { tex: { inlineMath: [['$', '$']] } };</script></body></html>