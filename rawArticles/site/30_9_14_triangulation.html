<html><head><title>!!INSERT TITLE HERE!!!</title><link rel='stylesheet' type='text/css' href='../main.css'><script src='../main.js'></script></head><body><h1>Mathematical Mistakes</h1>
<p><img lazy="../img/30_9_14/header.png" width="100%"></img></p>
<p><em>[This is reposted from the GameDev.net article I wrote earlier this year. #AltDevBlogADay recently went down without warning, and nobody knows why or where everybody who maintains the site are. For those of you who never used it, #AltDevBlog was a wealth of knowledge and tutorials put todether by people in the game programming industry, all compiled into one spot. With that gone, and only the WayBackMachine has the ability to help us understand <a href="http://altdevblogaday.com/2012/01/05/tricks-with-the-floating-point-format/">floating point formats</a>, behavior trees, <a href="http://altdevblogaday.com/2011/11/09/a-low-level-curriculum-for-c-and-c/">how to survive the disassembly window</a>, and a wealth of other amazing knowlede that I, for one, used to grow as a programmer and developer. I can't pretend to know why #AltDevBlog has been down for several months, or if the information is backed up somewhere somehow or not. However, in light of these recent events, I've decided to mirror my GameDev.net article to my website, just in case something like that ever happens to forum. It's not a very good article, but I think I should back it up anyways.]</em></p>
<p>Modern GPUs have an annoying habbit of only liking to draw triangles. Often when using 3D modeling programs or vector-based drawing applications to produce game art, you'll get instead a soup of arbitrary polygons. This is an issue if you plan to rasterize these polygons. Fortunately, polygons can be decomposed into triangles relatively easily.</p>
<p>There are many different ways to decompose polygons into triangles. Typically though you only implement an algorithm that's advanced enough to suit your needs. For example, convex polygons are easier to triangulate than concave ones, and polygons with a hole in the middle of it are a little complicated to get right (and are also beyond the scope of this article: I'll be covering ear clipping at the most in this article. Maybe for another article). If you know that you'll only ever be using convex polygons, then only implement the algorithm for convex polygon triangulation. No need to go overboard :)</p>
<h2>For Convex Polygons</h2>
<p>This one is by far the easiest. A convex polygon is one where there are no interior angles greater than 180 degrees in the polygon.</p>
<p><center>
<img src="../img/30_9_14/convex.png" alt="convex">
</center></p>
<pre><code>create a stack with all of the vertecies in CW/CCW order;
pop the top vertex off the stack and store in p0;
pop the top vertex off the stack and store in pHelper;
while the stack is not empty
    pop the top vertex off the stack and store in pTemp;
    create a triangle with vertices p0, pHelper, pTemp;
    let pHelper = pTemp</code></pre>
<p>The created triangle soup will be a complete triangulation of the polygon, but it only works with convex polygons!</p>
<h2>For Concave Polygons</h2>
<p>A concave polygon is a polygon that has at least one interior angle greater than 180 degrees. This also means that, for any concave polygon, there is at least one line that you can draw that will intersect the polygon at least 4 times.</p>
<p><center>
<img src="../img/30_9_14/comparison.png" alt="comparison">
</center>
For each and every closed polygon with more vertices than a triangle, convex or concave, there will always be at least two <a href="http://en.wikipedia.org/wiki/Ear_">"ears"</a> (the reason for this is more intuitive than anything: try drawing a polygon that doesn't have at least two ears; you'll find that doubling back to close the shape will inevitably end up creating at least two ears, normally). The way the algorithm works is that, after you clip off the ears of the original polygon, you end up with another closed polygon, with its own two ears to clip off. Rinse and repeat until you have no more ears left to clip off.</p>
<p>This algorithm is called "ear clipping." The image below shows how ear clipping procedurally degenerates a polygon into a soup of triangles by cutting off one corner at a time.</p>
<p>Here's the algorithm:</p>
<p><center>
<img src="../img/30_9_14/concave.png" alt="concave">
</center></p>
<pre><code>create a list of the vertices (perferably in CCW order, starting anywhere)
while true
  for every vertex
    let pPrev = the previous vertex in the list
    let pCur = the current vertex;
    let pNext = the next vertex in the list
    if the vertex is not an interior vertex (the wedge product of (pPrev - pCur) and (pNext - pCur) &lt;= 0, for CCW winding);
      continue;
    if there are any vertices in the polygon inside the triangle made by the current vertex and the two adjacent ones
      continue;
    create the triangle with the points pPrev, pCur, pNext, for a CCW triangle;
    remove pCur from the list;
  if no triangles were made in the above for loop
    break;</code></pre>
<h2>Polygons With Holes</h2>
<p>Again, this one is beyond the scope of this article, but the general trick to solving this case is to decompose the polygon into a set of monotone polygons:</p>
<p><center>
<img src="../img/30_9_14/monotone.png" alt="monotone">
</center></p>
<h1>Conclusion</h1>
<p>That's about it for most simple polygons you'll probably be creating in various art editors. For the most part, you shouldn't need any more than a concave polygon triangulator.</p>
<p>On a more case-specific note, I actually did need a more advanced triangulator, complete with support for triangulating bezier curves and the like. In the end, though, I decided to go with tile-based worlds and rasterized graphics, as they tended to end up looking better anyways :P</p>
<p>Well, the little thingy on the site says that I should write articles, no matter how trivial. In my defense, I know that I spent <i>much</i> more time than I should have needed to trying to figure out ear clipping. The same goes for monotone triangle decomposition, but that was just a matter of figuring out the state transitions.</p>
<p>Anyway, hope someone finds this helpful.</p>
<h3>Article Update Log</h3>
<ul>
<li><strong>8 June 2014</strong>: Added just a little more explanation, as per Aardvajk's advice</li>
<li><strong>6 June 2014</strong>: Initial release</li>
</ul>
<p>(Reposted on 30/9/14)</p>
<div id="disqus_thread"></div>

</body></html>